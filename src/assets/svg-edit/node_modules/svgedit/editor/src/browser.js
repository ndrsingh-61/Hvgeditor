

// Dependencies:
// 1) jQuery (for $.alert())

var svgedit = svgedit || {};

(function() {

if (!svgedit.browser) {
  svgedit.browser = {};
}
var supportsSvg_ = (function() {
        return !!document.createElementNS && !!document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect;
})();
svgedit.browser.supportsSvg = function() { return supportsSvg_; }
if(!svgedit.browser.supportsSvg()) {
  window.location = "browser-not-supported.html";
}
else{

var svgns = 'http://www.w3.org/2000/svg';
var userAgent = navigator.userAgent;
var svg = document.createElementNS(svgns, 'svg');
var isOpera_ = !!window.opera;
var isWebkit_ = userAgent.indexOf("AppleWebKit") >= 0;
var isGecko_ = userAgent.indexOf('Gecko/') >= 0;
var isIE_ = userAgent.indexOf('MSIE') >= 0;
var isChrome_ = userAgent.indexOf('Chrome/') >= 0;
var isWindows_ = userAgent.indexOf('Windows') >= 0;
var isMac_ = userAgent.indexOf('Macintosh') >= 0;
var isTouch_ = 'ontouchstart' in window;

var supportsSelectors_ = (function() {
  return !!svg.querySelector;
})();

var supportsXpath_ = (function() {
  return !!document.evaluate;
})();

// text character positioning (for IE9)
var supportsGoodTextCharPos_ = (function() {
   var svgroot = document.createElementNS(svgns, 'svg');
   var svgcontent = document.createElementNS(svgns, 'svg');
   document.documentElement.appendChild(svgroot);
   svgcontent.setAttribute('x', 5);
   svgroot.appendChild(svgcontent);
   var text = document.createElementNS(svgns,'text');
   text.textContent = 'a';
   svgcontent.appendChild(text);
   var pos = text.getStartPositionOfChar(0)
   pos = pos.x; //if you put it on one line it fails when compiled
   document.documentElement.removeChild(svgroot);
   return (pos === 0);
})();

var supportsEditableText_ = (function() {
  // TODO: Find better way to check support for this
  return isOpera_;
})();

var supportsNonScalingStroke_ = (function() {
  var rect = document.createElementNS(svgns, 'rect');
  rect.setAttribute('style','vector-effect:non-scaling-stroke');
  return rect.style.vectorEffect === 'non-scaling-stroke';
})();

var supportsNativeSVGTransformLists_ = (function() {
  var rect = document.createElementNS(svgns, 'rect');
  var rxform = rect.transform.baseVal;
  var t1 = svg.createSVGTransform();
  rxform.appendItem(t1);
  return rxform.getItem(0) == t1;
})();

// Public API

svgedit.browser.isOpera = function() { return isOpera_; }
svgedit.browser.isWebkit = function() { return isWebkit_; }
svgedit.browser.isGecko = function() { return isGecko_; }
svgedit.browser.isIE = function() { return isIE_; }
svgedit.browser.isChrome = function() { return isChrome_; }
svgedit.browser.isWindows = function() { return isWindows_; }
svgedit.browser.isMac = function() { return isMac_; }
svgedit.browser.isTouch = function() { return isTouch_; }

svgedit.browser.supportsSelectors = function() { return supportsSelectors_; }
svgedit.browser.supportsXpath = function() { return supportsXpath_; }
svgedit.browser.supportsGoodTextCharPos = function() { return supportsGoodTextCharPos_; }
svgedit.browser.supportsEditableText = function() { return supportsEditableText_; }
svgedit.browser.supportsNonScalingStroke = function() { return supportsNonScalingStroke_; }
svgedit.browser.supportsNativeTransformLists = function() { return supportsNativeSVGTransformLists_; }
}

})();


// SVGTransformList
var svgedit = svgedit || {};

(function() {

if (!svgedit.transformlist) {
  svgedit.transformlist = {};
}

var svgroot = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

// Helper function.
function transformToString(xform) {
  var m = xform.matrix,
    text = "";
  switch(xform.type) {
    case 1: // MATRIX
      text = "matrix(" + [m.a,m.b,m.c,m.d,m.e,m.f].join(",") + ")";
      break;
    case 2: // TRANSLATE
      text = "translate(" + m.e + "," + m.f + ")";
      break;
    case 3: // SCALE
      if (m.a == m.d) text = "scale(" + m.a + ")";
      else text = "scale(" + m.a + "," + m.d + ")";
      break;
    case 4: // ROTATE
      var cx = 0, cy = 0;
      // this prevents divide by zero
      if (xform.angle != 0) {
        var K = 1 - m.a;
        cy = ( K * m.f + m.b*m.e ) / ( K*K + m.b*m.b );
        cx = ( m.e - m.b * cy ) / K;
      }
      text = "rotate(" + xform.angle + " " + cx + "," + cy + ")";
      break;
  }
  return text;
};
/**
 * Map of SVGTransformList objects.
 */
var listMap_ = {};
svgedit.transformlist.SVGTransformList = function(elem) {
  this._elem = elem || null;
  this._xforms = [];
  // TODO: how do we capture the undo-ability in the changed transform list?
  this._update = function() {
    var tstr = "";
    var concatMatrix = svgroot.createSVGMatrix();
    for (var i = 0; i < this.numberOfItems; ++i) {
      var xform = this._list.getItem(i);
      tstr += transformToString(xform) + " ";
    }
    this._elem.setAttribute("transform", tstr);
  };
  this._list = this;
  this._init = function() {
    // Transform attribute parser
    var str = this._elem.getAttribute("transform");
    if(!str) return;
    
    // TODO: Add skew support in future
    var re = /\s*((scale|matrix|rotate|translate)\s*\(.*?\))\s*,?\s*/;
    var arr = [];
    var m = true;
    while(m) {
      m = str.match(re);
      str = str.replace(re,'');
      if(m && m[1]) {
        var x = m[1];
        var bits = x.split(/\s*\(/);
        var name = bits[0];
        var val_bits = bits[1].match(/\s*(.*?)\s*\)/);
        val_bits[1] = val_bits[1].replace(/(\d)-/g, "$1 -");
        var val_arr = val_bits[1].split(/[, ]+/);
        var letters = 'abcdef'.split('');
        var mtx = svgroot.createSVGMatrix();
        $.each(val_arr, function(i, item) {
          val_arr[i] = parseFloat(item);
          if(name == 'matrix') {
            mtx[letters[i]] = val_arr[i];
          }
        });
        var xform = svgroot.createSVGTransform();
        var fname = 'set' + name.charAt(0).toUpperCase() + name.slice(1);
        var values = name=='matrix'?[mtx]:val_arr;
        
        if (name == 'scale' && values.length == 1) {
          values.push(values[0]);
        } else if (name == 'translate' && values.length == 1) {
          values.push(0);
        } else if (name == 'rotate' && values.length == 1) {
          values.push(0);
          values.push(0);
        }
        xform[fname].apply(xform, values);
        this._list.appendItem(xform);
      }
    }
  };
  this._removeFromOtherLists = function(item) {
    if (item) {
      // Check if this transform is already in a transformlist, and
      // remove it if so.
      var found = false;
      for (var id in listMap_) {
        var tl = listMap_[id];
        for (var i = 0, len = tl._xforms.length; i < len; ++i) {
          if(tl._xforms[i] == item) {
            found = true;
            tl.removeItem(i);
            break;
          }
        }
        if (found) {
          break;
        }
      }
    }
  };
  
  this.numberOfItems = 0;
  this.clear = function() { 
    this.numberOfItems = 0;
    this._xforms = [];
  };
  
  this.initialize = function(newItem) {
    this.numberOfItems = 1;
    this._removeFromOtherLists(newItem);
    this._xforms = [newItem];
  };
  
  this.getItem = function(index) {
    if (index < this.numberOfItems && index >= 0) {
      return this._xforms[index];
    }
    throw {code: 1}; // DOMException with code=INDEX_SIZE_ERR
  };
  
  this.insertItemBefore = function(newItem, index) {
    var retValue = null;
    if (index >= 0) {
      if (index < this.numberOfItems) {
        this._removeFromOtherLists(newItem);
        var newxforms = new Array(this.numberOfItems + 1);
        // TODO: use array copying and slicing
        for ( var i = 0; i < index; ++i) {
          newxforms[i] = this._xforms[i];
        }
        newxforms[i] = newItem;
        for ( var j = i+1; i < this.numberOfItems; ++j, ++i) {
          newxforms[j] = this._xforms[i];
        }
        this.numberOfItems++;
        this._xforms = newxforms;
        retValue = newItem;
        this._list._update();
      }
      else {
        retValue = this._list.appendItem(newItem);
      }
    }
    return retValue;
  };
  
  this.replaceItem = function(newItem, index) {
    var retValue = null;
    if (index < this.numberOfItems && index >= 0) {
      this._removeFromOtherLists(newItem);
      this._xforms[index] = newItem;
      retValue = newItem;
      this._list._update();
    }
    return retValue;
  };
  
  this.removeItem = function(index) {
    if (index < this.numberOfItems && index >= 0) {
      var retValue = this._xforms[index];
      var newxforms = new Array(this.numberOfItems - 1);
      for (var i = 0; i < index; ++i) {
        newxforms[i] = this._xforms[i];
      }
      for (var j = i; j < this.numberOfItems-1; ++j, ++i) {
        newxforms[j] = this._xforms[i+1];
      }
      this.numberOfItems--;
      this._xforms = newxforms;
      this._list._update();
      return retValue;
    } else {
      throw {code: 1}; // DOMException with code=INDEX_SIZE_ERR
    }
  };
  
  this.appendItem = function(newItem) {
    this._removeFromOtherLists(newItem);
    this._xforms.push(newItem);
    this.numberOfItems++;
    this._list._update();
    return newItem;
  };
};
svgedit.transformlist.resetListMap = function() {
  listMap_ = {};
};
// Function: getTransformList
// Returns an object that behaves like a SVGTransformList for the given DOM element
//
// Parameters:
// elem - DOM element to get a transformlist from
svgedit.transformlist.getTransformList = function(elem) {
  if (!svgedit.browser.supportsNativeTransformLists()) {
    var id = elem.id;
    if(!id) {
      // Get unique ID for temporary element
      id = 'temp';
    }
    var t = listMap_[id];
    if (!t || id == 'temp') {
      listMap_[id] = new svgedit.transformlist.SVGTransformList(elem);
      listMap_[id]._init();
      t = listMap_[id];
    }
    return t;
  }
  else if (elem.transform) {
    return elem.transform.baseVal;
  }
  else if (elem.gradientTransform) {
    return elem.gradientTransform.baseVal;
  }
  else if (elem.patternTransform) {
    return elem.patternTransform.baseVal;
  }

  return null;
};
})();

//contextmenu
if(jQuery)( function() {
	$.extend($.fn, {
		// Disable context menu items on the fly
		disableContextMenuItems: function(o) {
			if( o == undefined ) {
				// Disable all
				$(this).find('LI').addClass('disabled');
				return( $(this) );
			}
			$(this).each( function() {
				if( o != undefined ) {
					var d = o.split(',');
					for( var i = 0; i < d.length; i++ ) {
						$(this).find('A[href="' + d[i] + '"]').parent().addClass('disabled');
						
					}
				}
			});
			return( $(this) );
		},
		// Enable context menu items on the fly
		enableContextMenuItems: function(o) {
			if( o == undefined ) {
				// Enable all
				$(this).find('LI.disabled').removeClass('disabled');
				return( $(this) );
			}
			$(this).each( function() {
				if( o != undefined ) {
					var d = o.split(',');
					for( var i = 0; i < d.length; i++ ) {
						$(this).find('A[href="' + d[i] + '"]').parent().removeClass('disabled');
						
					}
				}
			});
			return( $(this) );
		}
	});
})(jQuery);