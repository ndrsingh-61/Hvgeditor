/**
 * Package: svedit.math
 */

// Dependencies:
// None.

var svgedit = svgedit || {};

(function() {

if (!svgedit.math) {
  svgedit.math = {};
}

// Constants
var NEAR_ZERO = 1e-14;

// Throw away SVGSVGElement used for creating matrices/transforms.
var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

// Function: svgedit.math.transformPoint
// A (hopefully) quicker function to transform a point by a matrix
// (this function avoids any DOM calls and just does the math)
// 
// Parameters:
// x - Float representing the x coordinate
// y - Float representing the y coordinate
// m - Matrix object to transform the point with
// Returns a x,y object representing the transformed point
svgedit.math.transformPoint = function(x, y, m) {
  return { x: m.a * x + m.c * y + m.e, y: m.b * x + m.d * y + m.f};
};


// Function: svgedit.math.isIdentity
// Helper function to check if the matrix performs no actual transform 
// (i.e. exists for identity purposes)
//
// Parameters: 
// m - The matrix object to check
//
// Returns:
// Boolean indicating whether or not the matrix is 1,0,0,1,0,0
svgedit.math.isIdentity = function(m) {
  return (m.a === 1 && m.b === 0 && m.c === 0 && m.d === 1 && m.e === 0 && m.f === 0);
};


// Function: svgedit.math.matrixMultiply
// This function tries to return a SVGMatrix that is the multiplication m1*m2.
// We also round to zero when it's near zero
// 
// Parameters:
// >= 2 Matrix objects to multiply
//
// Returns: 
// The matrix object resulting from the calculation
svgedit.math.matrixMultiply = function() {
  var args = arguments, i = args.length, m = args[i-1];
  
  while(i-- > 1) {
    var m1 = args[i-1];
    m = m1.multiply(m);
  }
  if (Math.abs(m.a) < NEAR_ZERO) m.a = 0;
  if (Math.abs(m.b) < NEAR_ZERO) m.b = 0;
  if (Math.abs(m.c) < NEAR_ZERO) m.c = 0;
  if (Math.abs(m.d) < NEAR_ZERO) m.d = 0;
  if (Math.abs(m.e) < NEAR_ZERO) m.e = 0;
  if (Math.abs(m.f) < NEAR_ZERO) m.f = 0;
  
  return m;
};

// Function: svgedit.math.hasMatrixTransform
// See if the given transformlist includes a non-indentity matrix transform
//
// Parameters: 
// tlist - The transformlist to check
//
// Returns: 
// Boolean on whether or not a matrix transform was found
svgedit.math.hasMatrixTransform = function(tlist) {
  if(!tlist) return false;
  var num = tlist.numberOfItems;
  while (num--) {
    var xform = tlist.getItem(num);
    if (xform.type == 1 && !svgedit.math.isIdentity(xform.matrix)) return true;
  }
  return false;
};

// Function: svgedit.math.transformBox
// Transforms a rectangle based on the given matrix
//
// Parameters:
// l - Float with the box's left coordinate
// t - Float with the box's top coordinate
// w - Float with the box width
// h - Float with the box height
// m - Matrix object to transform the box by
// 
// Returns:
// An object with the following values:
// * tl - The top left coordinate (x,y object)
// * tr - The top right coordinate (x,y object)
// * bl - The bottom left coordinate (x,y object)
// * br - The bottom right coordinate (x,y object)
// * aabox - Object with the following values:
// * Float with the axis-aligned x coordinate
// * Float with the axis-aligned y coordinate
// * Float with the axis-aligned width coordinate
// * Float with the axis-aligned height coordinate
svgedit.math.transformBox = function(l, t, w, h, m) {
  var topleft = {x:l,y:t},
    topright = {x:(l+w),y:t},
    botright = {x:(l+w),y:(t+h)},
    botleft = {x:l,y:(t+h)};
  var transformPoint = svgedit.math.transformPoint;
  topleft = transformPoint( topleft.x, topleft.y, m );
  var minx = topleft.x,
    maxx = topleft.x,
    miny = topleft.y,
    maxy = topleft.y;
  topright = transformPoint( topright.x, topright.y, m );
  minx = Math.min(minx, topright.x);
  maxx = Math.max(maxx, topright.x);
  miny = Math.min(miny, topright.y);
  maxy = Math.max(maxy, topright.y);
  botleft = transformPoint( botleft.x, botleft.y, m);
  minx = Math.min(minx, botleft.x);
  maxx = Math.max(maxx, botleft.x);
  miny = Math.min(miny, botleft.y);
  maxy = Math.max(maxy, botleft.y);
  botright = transformPoint( botright.x, botright.y, m );
  minx = Math.min(minx, botright.x);
  maxx = Math.max(maxx, botright.x);
  miny = Math.min(miny, botright.y);
  maxy = Math.max(maxy, botright.y);

  return {tl:topleft, tr:topright, bl:botleft, br:botright, 
      aabox: {x:minx, y:miny, width:(maxx-minx), height:(maxy-miny)} };
};

// Function: svgedit.math.transformListToTransform
// This returns a single matrix Transform for a given Transform List
// (this is the equivalent of SVGTransformList.consolidate() but unlike
//  that method, this one does not modify the actual SVGTransformList)
// This function is very liberal with its min,max arguments
// 
// Parameters:
// tlist - The transformlist object
// min - Optional integer indicating start transform position
// max - Optional integer indicating end transform position
//
// Returns:
// A single matrix transform object
svgedit.math.transformListToTransform = function(tlist, min, max) {
  if(tlist == null) {
    // Or should tlist = null have been prevented before this?
    return svg.createSVGTransformFromMatrix(svg.createSVGMatrix());
  }
  var min = min == undefined ? 0 : min;
  var max = max == undefined ? (tlist.numberOfItems-1) : max;
  min = parseInt(min);
  max = parseInt(max);
  if (min > max) { var temp = max; max = min; min = temp; }
  var m = svg.createSVGMatrix();
  for (var i = min; i <= max; ++i) {
    // if our indices are out of range, just use a harmless identity matrix
    var mtom = (i >= 0 && i < tlist.numberOfItems ? 
            tlist.getItem(i).matrix :
            svg.createSVGMatrix());
    m = svgedit.math.matrixMultiply(m, mtom);
  }
  return svg.createSVGTransformFromMatrix(m);
};


// Function: svgedit.math.getMatrix
// Get the matrix object for a given element
//
// Parameters:
// elem - The DOM element to check
// 
// Returns:
// The matrix object associated with the element's transformlist
svgedit.math.getMatrix = function(elem) {
  var tlist = svgedit.transformlist.getTransformList(elem);
  return svgedit.math.transformListToTransform(tlist).matrix;
};


// Function: svgedit.math.snapToAngle
// Returns a 45 degree angle coordinate associated with the two given 
// coordinates
// 
// Parameters:
// x1 - First coordinate's x value
// x2 - Second coordinate's x value
// y1 - First coordinate's y value
// y2 - Second coordinate's y value
//
// Returns: 
// Object with the following values:
// x - The angle-snapped x value
// y - The angle-snapped y value
// snapangle - The angle at which to snap
svgedit.math.snapToAngle = function(x1,y1,x2,y2) {
  var snap = Math.PI/4; // 45 degrees
  var dx = x2 - x1;
  var dy = y2 - y1;
  var angle = Math.atan2(dy,dx);
  var dist = Math.sqrt(dx * dx + dy * dy);
  var snapangle= Math.round(angle/snap)*snap;
  var x = x1 + dist*Math.cos(snapangle);  
  var y = y1 + dist*Math.sin(snapangle);
  //console.log(x1,y1,x2,y2,x,y,angle)
  return {x:x, y:y, a:snapangle};
};


// Function: rectsIntersect
// Check if two rectangles (BBoxes objects) intersect each other
//
// Paramaters:
// r1 - The first BBox-like object
// r2 - The second BBox-like object
//
// Returns:
// Boolean that's true if rectangles intersect
svgedit.math.rectsIntersect = function(r1, r2) {
  if (!r1 || !r2) return false;
  return r2.x < (r1.x+r1.width) && 
    (r2.x+r2.width) > r1.x &&
    r2.y < (r1.y+r1.height) &&
    (r2.y+r2.height) > r1.y;
};


})();

//units
var svgedit = svgedit || {};

(function() {

if (!svgedit.units) {
  svgedit.units = {};
}

var w_attrs = ['x', 'x1', 'cx', 'rx', 'width'];
var h_attrs = ['y', 'y1', 'cy', 'ry', 'height'];
var unit_attrs = $.merge(['r','radius'], w_attrs);

var unitNumMap = {
  '%':  2,
  'em': 3,
  'ex': 4,
  'px': 5,
  'cm': 6,
  'mm': 7,
  'in': 8,
  'pt': 9,
  'pc': 10
};

$.merge(unit_attrs, h_attrs);

// Container of elements.
var elementContainer_;

/**
 * Stores mapping of unit type to user coordinates.
 */
var typeMap_ = {px: 1};

/**
 * ElementContainer interface
 *
 * function getBaseUnit() - returns a string of the base unit type of the container ("em")
 * function getElement() - returns an element in the container given an id
 * function getHeight() - returns the container's height
 * function getWidth() - returns the container's width
 * function getRoundDigits() - returns the number of digits number should be rounded to
 */

/**
 * Function: svgedit.units.init()
 * Initializes this module.
 *
 * Parameters:
 * elementContainer - an object implementing the ElementContainer interface.
 */
svgedit.units.init = function(elementContainer) {
  elementContainer_ = elementContainer;

  var svgns = 'http://www.w3.org/2000/svg';

  // Get correct em/ex values by creating a temporary SVG.
  var svg = document.createElementNS(svgns, 'svg');
  document.body.appendChild(svg);
  var rect = document.createElementNS(svgns,'rect');
  rect.setAttribute('width',"1em");
  rect.setAttribute('height',"1ex");
  rect.setAttribute('x',"1in");
  svg.appendChild(rect);
  var bb = rect.getBBox();
  document.body.removeChild(svg);

  var inch = bb.x;
  typeMap_['em'] = bb.width;
  typeMap_['ex'] = bb.height;
  typeMap_['in'] = inch;
  typeMap_['cm'] = inch / 2.54;
  typeMap_['mm'] = inch / 25.4;
  typeMap_['pt'] = inch / 72;
  typeMap_['pc'] = inch / 6;
  typeMap_['%'] = 0;
};

// Group: Unit conversion functions

// Function: svgedit.units.getTypeMap
// Returns the unit object with values for each unit
svgedit.units.getTypeMap = function() {
  return typeMap_;
};

// Function: svgedit.units.shortFloat
// Rounds a given value to a float with number of digits defined in save_options
//
// Parameters: 
// val - The value as a String, Number or Array of two numbers to be rounded
//
// Returns:
// If a string/number was given, returns a Float. If an array, return a string
// with comma-seperated floats
svgedit.units.shortFloat = function(val) {
  var digits = elementContainer_.getRoundDigits();
  if(!isNaN(val)) {
    // Note that + converts to Number
    return +((+val).toFixed(digits));
  } else if($.isArray(val)) {
    return svgedit.units.shortFloat(val[0]) + ',' + svgedit.units.shortFloat(val[1]);
  }
  return parseFloat(val).toFixed(digits) - 0;
};

// Function: svgedit.units.convertUnit
// Converts the number to given unit or baseUnit
svgedit.units.convertUnit = function(val, unit) {
  unit = unit || elementContainer_.getBaseUnit();
//  baseVal.convertToSpecifiedUnits(unitNumMap[unit]);
//  var val = baseVal.valueInSpecifiedUnits;
//  baseVal.convertToSpecifiedUnits(1);
  return svgedit.unit.shortFloat(val / typeMap_[unit]);
};

// Function: svgedit.units.setUnitAttr
// Sets an element's attribute based on the unit in its current value.
//
// Parameters: 
// elem - DOM element to be changed
// attr - String with the name of the attribute associated with the value
// val - String with the attribute value to convert
svgedit.units.setUnitAttr = function(elem, attr, val) {
  if(!isNaN(val)) {
    // New value is a number, so check currently used unit
    var old_val = elem.getAttribute(attr);
    
    // Enable this for alternate mode
//    if(old_val !== null && (isNaN(old_val) || elementContainer_.getBaseUnit() !== 'px')) {
//      // Old value was a number, so get unit, then convert
//      var unit;
//      if(old_val.substr(-1) === '%') {
//        var res = getResolution();
//        unit = '%';
//        val *= 100;
//        if(w_attrs.indexOf(attr) >= 0) {
//          val = val / res.w;
//        } else if(h_attrs.indexOf(attr) >= 0) {
//          val = val / res.h;
//        } else {
//          return val / Math.sqrt((res.w*res.w) + (res.h*res.h))/Math.sqrt(2);
//        }
//      } else {
//        if(elementContainer_.getBaseUnit() !== 'px') {
//          unit = elementContainer_.getBaseUnit();
//        } else {
//          unit = old_val.substr(-2);
//        }
//        val = val / typeMap_[unit];
//      }
//    
//    val += unit;
//    }
  }
  elem.setAttribute(attr, val);
};

var attrsToConvert = {
  "line": ['x1', 'x2', 'y1', 'y2'],
  "circle": ['cx', 'cy', 'r'],
  "ellipse": ['cx', 'cy', 'rx', 'ry'],
  "foreignObject": ['x', 'y', 'width', 'height'],
  "rect": ['x', 'y', 'width', 'height'],
  "image": ['x', 'y', 'width', 'height'],
  "use": ['x', 'y', 'width', 'height'],
  "text": ['x', 'y']
};

// Function: svgedit.units.convertAttrs
// Converts all applicable attributes to the configured baseUnit
//
// Parameters:
// element - a DOM element whose attributes should be converted
svgedit.units.convertAttrs = function(element) {
  var elName = element.tagName;
  var unit = elementContainer_.getBaseUnit();
  var attrs = attrsToConvert[elName];
  if(!attrs) return;
  var len = attrs.length
  for(var i = 0; i < len; i++) {
    var attr = attrs[i];
    var cur = element.getAttribute(attr);
    if(cur) {
      if(!isNaN(cur)) {
        element.setAttribute(attr, (cur / typeMap_[unit]) + unit);
      } else {
        // Convert existing?
      }
    }
  }
};

// Function: svgedit.units.convertToNum
// Converts given values to numbers. Attributes must be supplied in 
// case a percentage is given
//
// Parameters:
// attr - String with the name of the attribute associated with the value
// val - String with the attribute value to convert
svgedit.units.convertToNum = function(attr, val) {
  // Return a number if that's what it already is
  if(!isNaN(val)) return val-0;
  
  if(val.substr(-1) === '%') {
    // Deal with percentage, depends on attribute
    var num = val.substr(0, val.length-1)/100;
    var width = elementContainer_.getWidth();
    var height = elementContainer_.getHeight();
    
    if(w_attrs.indexOf(attr) >= 0) {
      return num * width;
    } else if(h_attrs.indexOf(attr) >= 0) {
      return num * height;
    } else {
      return num * Math.sqrt((width*width) + (height*height))/Math.sqrt(2);
    }
  } else {
    var unit = val.substr(-2);
    var num = val.substr(0, val.length-2);
    // Note that this multiplication turns the string into a number
    return num * typeMap_[unit];
  }
};

// Function: svgedit.units.isValidUnit
// Check if an attribute's value is in a valid format
//
// Parameters: 
// attr - String with the name of the attribute associated with the value
// val - String with the attribute value to check
svgedit.units.isValidUnit = function(attr, val, selectedElement) {
  var valid = false;
  if(unit_attrs.indexOf(attr) >= 0) {
    // True if it's just a number
    if(!isNaN(val)) {
      valid = true;
    } else {
    // Not a number, check if it has a valid unit
      val = val.toLowerCase();
      $.each(typeMap_, function(unit) {
        if(valid) return;
        var re = new RegExp('^-?[\\d\\.]+' + unit + '$');
        if(re.test(val)) valid = true;
      });
    }
  } else if (attr == "id") {
     var result = false;
    
    try {
      var elem = elementContainer_.getElement(val);
      result = (elem == null || elem === selectedElement);
    } catch(e) {}
    return result;
  } else {
    valid = true;
  }
  
  return valid;
};
})();

var svgedit = svgedit || {};

(function() {

if (!svgedit.history) {
  svgedit.history = {};
}

// Group: Undo/Redo history management


svgedit.history.HistoryEventTypes = {
  BEFORE_APPLY: 'before_apply',
  AFTER_APPLY: 'after_apply',
  BEFORE_UNAPPLY: 'before_unapply',
  AFTER_UNAPPLY: 'after_unapply'
};

var removedElements = {};

/**
 * Interface: svgedit.history.HistoryCommand
 * An interface that all command objects must implement.
 *
 * interface svgedit.history.HistoryCommand {
 *   void apply(svgedit.history.HistoryEventHandler);
 *   void unapply(svgedit.history.HistoryEventHandler);
 *   Element[] elements();
 *   String getText();
 *
 *   static String type();
 * }
 *
 * Interface: svgedit.history.HistoryEventHandler
 * An interface for objects that will handle history events.
 *
 * interface svgedit.history.HistoryEventHandler {
 *   void handleHistoryEvent(eventType, command);
 * }
 *
 * eventType is a string conforming to one of the HistoryEvent types.
 * command is an object fulfilling the HistoryCommand interface.
 */

// Class: svgedit.history.MoveElementCommand
// implements svgedit.history.HistoryCommand
// History command for an element that had its DOM position changed
//
// Parameters:
// elem - The DOM element that was moved
// oldNextSibling - The element's next sibling before it was moved
// oldParent - The element's parent before it was moved
// text - An optional string visible to user related to this change
svgedit.history.MoveElementCommand = function(elem, oldNextSibling, oldParent, text) {
  this.elem = elem;
  this.text = text ? ("Move " + elem.tagName + " to " + text) : ("Move " + elem.tagName);
  this.oldNextSibling = oldNextSibling;
  this.oldParent = oldParent;
  this.newNextSibling = elem.nextSibling;
  this.newParent = elem.parentNode;
};
svgedit.history.MoveElementCommand.type = function() { return 'svgedit.history.MoveElementCommand'; }
svgedit.history.MoveElementCommand.prototype.type = svgedit.history.MoveElementCommand.type;

// Function: svgedit.history.MoveElementCommand.getText
svgedit.history.MoveElementCommand.prototype.getText = function() {
  return this.text;
};

// Function: svgedit.history.MoveElementCommand.apply
// Re-positions the element
svgedit.history.MoveElementCommand.prototype.apply = function(handler) {
  // TODO(codedread): Refactor this common event code into a base HistoryCommand class.
  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_APPLY, this);
  }

  this.elem = this.newParent.insertBefore(this.elem, this.newNextSibling);

  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_APPLY, this);
  }
};

// Function: svgedit.history.MoveElementCommand.unapply
// Positions the element back to its original location
svgedit.history.MoveElementCommand.prototype.unapply = function(handler) {
  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_UNAPPLY, this);
  }
    
  this.elem = this.oldParent.insertBefore(this.elem, this.oldNextSibling);

  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_UNAPPLY, this);
  }
};

// Function: svgedit.history.MoveElementCommand.elements
// Returns array with element associated with this command
svgedit.history.MoveElementCommand.prototype.elements = function() {
  return [this.elem];
};


// Class: svgedit.history.InsertElementCommand
// implements svgedit.history.HistoryCommand
// History command for an element that was added to the DOM
//
// Parameters:
// elem - The newly added DOM element
// text - An optional string visible to user related to this change
svgedit.history.InsertElementCommand = function(elem, text) {
  this.elem = elem;
  this.text = text || ("Create " + elem.tagName);
  this.parent = elem.parentNode;
  this.nextSibling = this.elem.nextSibling;
};
svgedit.history.InsertElementCommand.type = function() { return 'svgedit.history.InsertElementCommand'; }
svgedit.history.InsertElementCommand.prototype.type = svgedit.history.InsertElementCommand.type;

// Function: svgedit.history.InsertElementCommand.getText
svgedit.history.InsertElementCommand.prototype.getText = function() {
  return this.text;
};

// Function: svgedit.history.InsertElementCommand.apply
// Re-Inserts the new element
svgedit.history.InsertElementCommand.prototype.apply = function(handler) { 
  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_APPLY, this);
  }

  this.elem = this.parent.insertBefore(this.elem, this.nextSibling); 

  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_APPLY, this);
  }
};

// Function: svgedit.history.InsertElementCommand.unapply
// Removes the element
svgedit.history.InsertElementCommand.prototype.unapply = function(handler) {
  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_UNAPPLY, this);
  }

  this.parent = this.elem.parentNode;
  this.elem = this.elem.parentNode.removeChild(this.elem);

  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_UNAPPLY, this);
  }
};

// Function: svgedit.history.InsertElementCommand.elements
// Returns array with element associated with this command
svgedit.history.InsertElementCommand.prototype.elements = function() {
  return [this.elem];
};


// Class: svgedit.history.RemoveElementCommand
// implements svgedit.history.HistoryCommand
// History command for an element removed from the DOM
//
// Parameters:
// elem - The removed DOM element
// oldNextSibling - the DOM element's nextSibling when it was in the DOM
// oldParent - The DOM element's parent
// text - An optional string visible to user related to this change
svgedit.history.RemoveElementCommand = function(elem, oldNextSibling, oldParent, text) {
  this.elem = elem;
  this.text = text || ("Delete " + elem.tagName);
  this.nextSibling = oldNextSibling;
  this.parent = oldParent;

  // special hack for webkit: remove this element's entry in the svgTransformLists map
  svgedit.transformlist.removeElementFromListMap(elem);
};
svgedit.history.RemoveElementCommand.type = function() { return 'svgedit.history.RemoveElementCommand'; }
svgedit.history.RemoveElementCommand.prototype.type = svgedit.history.RemoveElementCommand.type;

// Function: svgedit.history.RemoveElementCommand.getText
svgedit.history.RemoveElementCommand.prototype.getText = function() {
  return this.text;
};

// Function: RemoveElementCommand.apply
// Re-removes the new element
svgedit.history.RemoveElementCommand.prototype.apply = function(handler) {  
  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_APPLY, this);
  }

  svgedit.transformlist.removeElementFromListMap(this.elem);
  this.parent = this.elem.parentNode;
  this.elem = this.parent.removeChild(this.elem);

  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_APPLY, this);
  }
};

// Function: RemoveElementCommand.unapply
// Re-adds the new element
svgedit.history.RemoveElementCommand.prototype.unapply = function(handler) { 
  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_UNAPPLY, this);
  }

  svgedit.transformlist.removeElementFromListMap(this.elem);
  if(this.nextSibling == null) {
    if(window.console) console.log('Error: reference element was lost');
  }
  this.parent.insertBefore(this.elem, this.nextSibling);


  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_UNAPPLY, this);
  }
};

// Function: RemoveElementCommand.elements
// Returns array with element associated with this command
svgedit.history.RemoveElementCommand.prototype.elements = function() {
  return [this.elem];
};


// Class: svgedit.history.ChangeElementCommand
// implements svgedit.history.HistoryCommand
// History command to make a change to an element. 
// Usually an attribute change, but can also be textcontent.
//
// Parameters:
// elem - The DOM element that was changed
// attrs - An object with the attributes to be changed and the values they had *before* the change
// text - An optional string visible to user related to this change
svgedit.history.ChangeElementCommand = function(elem, attrs, text) {
  this.elem = elem;
  this.text = text ? ("Change " + elem.tagName + " " + text) : ("Change " + elem.tagName);
  this.newValues = {};
  this.oldValues = attrs;
  for (var attr in attrs) {
    if (attr == "#text") this.newValues[attr] = elem.textContent;
    else if (attr == "#href") this.newValues[attr] = svgedit.utilities.getHref(elem);
    else this.newValues[attr] = elem.getAttribute(attr);
  }
};
svgedit.history.ChangeElementCommand.type = function() { return 'svgedit.history.ChangeElementCommand'; }
svgedit.history.ChangeElementCommand.prototype.type = svgedit.history.ChangeElementCommand.type;

// Function: svgedit.history.ChangeElementCommand.getText
svgedit.history.ChangeElementCommand.prototype.getText = function() {
  return this.text;
};

// Function: svgedit.history.ChangeElementCommand.apply
// Performs the stored change action
svgedit.history.ChangeElementCommand.prototype.apply = function(handler) {
  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_APPLY, this);
  }

  var bChangedTransform = false;
  for(var attr in this.newValues ) {
    if (this.newValues[attr]) {
      if (attr == "#text") this.elem.textContent = this.newValues[attr];
      else if (attr == "#href") svgedit.utilities.setHref(this.elem, this.newValues[attr])
      else this.elem.setAttribute(attr, this.newValues[attr]);
    }
    else {
      if (attr == "#text") {
        this.elem.textContent = "";
      }
      else {
        this.elem.setAttribute(attr, "");
        this.elem.removeAttribute(attr);
      }
    }

    if (attr == "transform") { bChangedTransform = true; }
  }

  // relocate rotational transform, if necessary
  if(!bChangedTransform) {
    var angle = svgedit.utilities.getRotationAngle(this.elem);
    if (angle) {
      var bbox = elem.getBBox();
      var cx = bbox.x + bbox.width/2,
        cy = bbox.y + bbox.height/2;
      var rotate = ["rotate(", angle, " ", cx, ",", cy, ")"].join('');
      if (rotate != elem.getAttribute("transform")) {
        elem.setAttribute("transform", rotate);
      }
    }
  }

  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_APPLY, this);
  }

  return true;
};

// Function: svgedit.history.ChangeElementCommand.unapply
// Reverses the stored change action
svgedit.history.ChangeElementCommand.prototype.unapply = function(handler) {
  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_UNAPPLY, this);
  }

  var bChangedTransform = false;
  for(var attr in this.oldValues ) {
    if (this.oldValues[attr]) {
      if (attr == "#text") this.elem.textContent = this.oldValues[attr];
      else if (attr == "#href") svgedit.utilities.setHref(this.elem, this.oldValues[attr]);
      else this.elem.setAttribute(attr, this.oldValues[attr]);
    }
    else {
      if (attr == "#text") {
        this.elem.textContent = "";
      }
      else this.elem.removeAttribute(attr);
    }
    if (attr == "transform") { bChangedTransform = true; }
  }
  // relocate rotational transform, if necessary
  if(!bChangedTransform) {
    var angle = svgedit.utilities.getRotationAngle(this.elem);
    if (angle) {
      var bbox = this.elem.getBBox();
      var cx = bbox.x + bbox.width/2,
        cy = bbox.y + bbox.height/2;
      var rotate = ["rotate(", angle, " ", cx, ",", cy, ")"].join('');
      if (rotate != this.elem.getAttribute("transform")) {
        this.elem.setAttribute("transform", rotate);
      }
    }
  }

  // Remove transformlist to prevent confusion that causes bugs like 575.
  svgedit.transformlist.removeElementFromListMap(this.elem);

  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_UNAPPLY, this);
  }

  return true;
};

// Function: ChangeElementCommand.elements
// Returns array with element associated with this command
svgedit.history.ChangeElementCommand.prototype.elements = function() {
  return [this.elem];
};


// TODO: create a 'typing' command object that tracks changes in text
// if a new Typing command is created and the top command on the stack is also a Typing
// and they both affect the same element, then collapse the two commands into one


// Class: svgedit.history.BatchCommand
// implements svgedit.history.HistoryCommand
// History command that can contain/execute multiple other commands
//
// Parameters:
// text - An optional string visible to user related to this change
svgedit.history.BatchCommand = function(text) {
  this.text = text || "Batch Command";
  this.stack = [];
};
svgedit.history.BatchCommand.type = function() { return 'svgedit.history.BatchCommand'; }
svgedit.history.BatchCommand.prototype.type = svgedit.history.BatchCommand.type;

// Function: svgedit.history.BatchCommand.getText
svgedit.history.BatchCommand.prototype.getText = function() {
  return this.text;
};

// Function: svgedit.history.BatchCommand.apply
// Runs "apply" on all subcommands
svgedit.history.BatchCommand.prototype.apply = function(handler) {
  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_APPLY, this);
  }

  var len = this.stack.length;
  for (var i = 0; i < len; ++i) {
    this.stack[i].apply(handler);
  }

  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_APPLY, this);
  }
};

// Function: svgedit.history.BatchCommand.unapply
// Runs "unapply" on all subcommands
svgedit.history.BatchCommand.prototype.unapply = function(handler) {
  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_UNAPPLY, this);
  }

  for (var i = this.stack.length-1; i >= 0; i--) {
    this.stack[i].unapply(handler);
  }

  if (handler) {
    handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_UNAPPLY, this);
  }
};

// Function: svgedit.history.BatchCommand.elements
// Iterate through all our subcommands and returns all the elements we are changing
svgedit.history.BatchCommand.prototype.elements = function() {
  var elems = [];
  var cmd = this.stack.length;
  while (cmd--) {
    var thisElems = this.stack[cmd].elements();
    var elem = thisElems.length;
    while (elem--) {
      if (elems.indexOf(thisElems[elem]) == -1) elems.push(thisElems[elem]);
    }
  }
  return elems;
};

// Function: svgedit.history.BatchCommand.addSubCommand
// Adds a given command to the history stack
//
// Parameters:
// cmd - The undo command object to add
svgedit.history.BatchCommand.prototype.addSubCommand = function(cmd) {
  this.stack.push(cmd);
};

// Function: svgedit.history.BatchCommand.isEmpty
// Returns a boolean indicating whether or not the batch command is empty
svgedit.history.BatchCommand.prototype.isEmpty = function() {
  return this.stack.length == 0;
};


// Class: svgedit.history.UndoManager
// Parameters:
// historyEventHandler - an object that conforms to the HistoryEventHandler interface
// (see above)
svgedit.history.UndoManager = function(historyEventHandler) {
  this.handler_ = historyEventHandler || null;
  this.undoStackPointer = 0;
  this.undoStack = [];

  // this is the stack that stores the original values, the elements and
  // the attribute name for begin/finish
  this.undoChangeStackPointer = -1;
  this.undoableChangeStack = [];
};
  
// Function: svgedit.history.UndoManager.resetUndoStack
// Resets the undo stack, effectively clearing the undo/redo history
svgedit.history.UndoManager.prototype.resetUndoStack = function() {
  this.undoStack = [];
  this.undoStackPointer = 0;
};

// Function: svgedit.history.UndoManager.getUndoStackSize
// Returns: 
// Integer with the current size of the undo history stack
svgedit.history.UndoManager.prototype.getUndoStackSize = function() {
  return this.undoStackPointer;
};

// Function: svgedit.history.UndoManager.getRedoStackSize
// Returns: 
// Integer with the current size of the redo history stack
svgedit.history.UndoManager.prototype.getRedoStackSize = function() {
  return this.undoStack.length - this.undoStackPointer;
};

// Function: svgedit.history.UndoManager.getNextUndoCommandText
// Returns: 
// String associated with the next undo command
svgedit.history.UndoManager.prototype.getNextUndoCommandText = function() { 
  return this.undoStackPointer > 0 ? this.undoStack[this.undoStackPointer-1].getText() : "";
};

// Function: svgedit.history.UndoManager.getNextRedoCommandText
// Returns: 
// String associated with the next redo command
svgedit.history.UndoManager.prototype.getNextRedoCommandText = function() { 
  return this.undoStackPointer < this.undoStack.length ? this.undoStack[this.undoStackPointer].getText() : "";
};

// Function: svgedit.history.UndoManager.undo
// Performs an undo step
svgedit.history.UndoManager.prototype.undo = function() {
  if (this.undoStackPointer > 0) {
    var cmd = this.undoStack[--this.undoStackPointer];
    cmd.unapply(this.handler_);
  }
};

// Function: svgedit.history.UndoManager.redo   
// Performs a redo step
svgedit.history.UndoManager.prototype.redo = function() {
  if (this.undoStackPointer < this.undoStack.length && this.undoStack.length > 0) {
    var cmd = this.undoStack[this.undoStackPointer++];
    cmd.apply(this.handler_);
  }
};
  
// Function: svgedit.history.UndoManager.addCommandToHistory
// Adds a command object to the undo history stack
//
// Parameters: 
// cmd - The command object to add
svgedit.history.UndoManager.prototype.addCommandToHistory = function(cmd) {
  // FIXME: we MUST compress consecutive text changes to the same element
  // (right now each keystroke is saved as a separate command that includes the
  // entire text contents of the text element)
  // TODO: consider limiting the history that we store here (need to do some slicing)
  
  // if our stack pointer is not at the end, then we have to remove
  // all commands after the pointer and insert the new command
  if (this.undoStackPointer < this.undoStack.length && this.undoStack.length > 0) {
    this.undoStack = this.undoStack.splice(0, this.undoStackPointer);
  }
  this.undoStack.push(cmd);
  this.undoStackPointer = this.undoStack.length;
};


// Function: svgedit.history.UndoManager.beginUndoableChange
// This function tells the canvas to remember the old values of the 
// attrName attribute for each element sent in.  The elements and values 
// are stored on a stack, so the next call to finishUndoableChange() will 
// pop the elements and old values off the stack, gets the current values
// from the DOM and uses all of these to construct the undo-able command.
//
// Parameters: 
// attrName - The name of the attribute being changed
// elems - Array of DOM elements being changed
svgedit.history.UndoManager.prototype.beginUndoableChange = function(attrName, elems) {
  var p = ++this.undoChangeStackPointer;
  var i = elems.length;
  var oldValues = new Array(i), elements = new Array(i);
  while (i--) {
    var elem = elems[i];
    if (elem == null) continue;
    elements[i] = elem;
    oldValues[i] = elem.getAttribute(attrName);
  }
  this.undoableChangeStack[p] = {'attrName': attrName,
              'oldValues': oldValues,
              'elements': elements};
};

// Function: svgedit.history.UndoManager.finishUndoableChange
// This function returns a BatchCommand object which summarizes the
// change since beginUndoableChange was called.  The command can then
// be added to the command history
//
// Returns: 
// Batch command object with resulting changes
svgedit.history.UndoManager.prototype.finishUndoableChange = function() {
  var p = this.undoChangeStackPointer--;
  var changeset = this.undoableChangeStack[p];
  var i = changeset['elements'].length;
  var attrName = changeset['attrName'];
  var batchCmd = new svgedit.history.BatchCommand("Change " + attrName);
  while (i--) {
    var elem = changeset['elements'][i];
    if (elem == null) continue;
    var changes = {};
    changes[attrName] = changeset['oldValues'][i];
    if (changes[attrName] != elem.getAttribute(attrName)) {
      batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(elem, changes, attrName));
    }
  }
  this.undoableChangeStack[p] = null;
  return batchCmd;
};


})();