

var svgedit = svgedit || {};

(function() {

if (!svgedit.utilities) {
  svgedit.utilities = {};
}
var KEYSTR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var SVGNS = 'http://www.w3.org/2000/svg';
var XLINKNS = 'http://www.w3.org/1999/xlink';
var XMLNS = "http://www.w3.org/XML/1998/namespace";

var visElems = 'a,circle,ellipse,foreignObject,g,image,line,path,polygon,polyline,rect,svg,text,tspan,use';
var visElems_arr = visElems.split(',');
var editorContext_ = null;
var domdoc_ = null;
var domcontainer_ = null;
var svgroot_ = null;

svgedit.utilities.init = function(editorContext) {
  editorContext_ = editorContext;
  domdoc_ = editorContext.getDOMDocument();
  domcontainer_ = editorContext.getDOMContainer();
  svgroot_ = editorContext.getSVGRoot();
};

// Function: svgedit.utilities.toXml
// Converts characters in a string to XML-friendly entities.
// Parameters:
// str - The string to be converted
//
// Returns:
// The converted string
svgedit.utilities.toXml = function(str) {
  return $('<p/>').text(str).html();
};
  
// Function: svgedit.utilities.fromXml
// Converts XML entities in a string to single characters. 
// Example: "&amp;" becomes "&"
//
// Parameters:
// str - The string to be converted
//
// Returns: 
// The converted string
svgedit.utilities.fromXml = function(str) {
  return $('<p/>').html(str).text();
};

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.

// schiller: Removed string concatenation in favour of Array.join() optimization,
//           also precalculate the size of the array needed.

// Function: svgedit.utilities.encode64
// Converts a string to base64
svgedit.utilities.encode64 = function(input) {
  // base64 strings are 4/3 larger than the original string
//  input = svgedit.utilities.encodeUTF8(input); // convert non-ASCII characters
  input = svgedit.utilities.convertToXMLReferences(input);
  if(window.btoa) return window.btoa(input); // Use native if available
  var output = new Array( Math.floor( (input.length + 2) / 3 ) * 4 );
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0, p = 0;

  do {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++);

    enc1 = chr1 >> 2;
    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
    enc4 = chr3 & 63;

    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }

    output[p++] = KEYSTR.charAt(enc1);
    output[p++] = KEYSTR.charAt(enc2);
    output[p++] = KEYSTR.charAt(enc3);
    output[p++] = KEYSTR.charAt(enc4);
  } while (i < input.length);

  return output.join('');
};

// Function: svgedit.utilities.convertToXMLReferences 
// Converts a string to use XML references
svgedit.utilities.convertToXMLReferences = function(input) {
  var output = '';
  for (var n = 0; n < input.length; n++){
    var c = input.charCodeAt(n);
    if (c < 128) {
      output += input[n];
    } else if(c > 127) {
      output += ("&#" + c + ";");
    }
  }
  return output;
};
svgedit.utilities.text2xml = function(sXML) {
  if(sXML.indexOf('<svg:svg') >= 0) {
    sXML = sXML.replace(/<(\/?)svg:/g, '<$1').replace('xmlns:svg', 'xmlns');
  }

  var out;
  try{
    var dXML = (window.DOMParser)?new DOMParser():new ActiveXObject("Microsoft.XMLDOM");
    dXML.async = false;
  } catch(e){ 
    throw new Error("XML Parser could not be instantiated"); 
  };
  try{
    if(dXML.loadXML) out = (dXML.loadXML(sXML))?dXML:false;
    else out = dXML.parseFromString(sXML, "text/xml");
  }
  catch(e){ throw new Error("Error parsing XML string"); };
  return out;
};
// Function: svgedit.utilities.bboxToObj
// Converts a SVGRect into an object.
// 
// Parameters:
// bbox - a SVGRect
// 
// Returns:
// An object with properties names x, y, width, height.
svgedit.utilities.bboxToObj = function(bbox) {
  return {
    x: bbox.x,
    y: bbox.y,
    width: bbox.width,
    height: bbox.height
  }
};
// Parameters:
// attrVal - The attribute value as a string
// 
// Returns:
// String with just the URL, like someFile.svg#foo
svgedit.utilities.getUrlFromAttr = function(attrVal) {
  if (attrVal) {    
    // url("#somegrad")
    if (attrVal.indexOf('url("') === 0) {
      return attrVal.substring(5,attrVal.indexOf('"',6));
    }
    // url('#somegrad')
    else if (attrVal.indexOf("url('") === 0) {
      return attrVal.substring(5,attrVal.indexOf("'",6));
    }
    else if (attrVal.indexOf("url(") === 0) {
      return attrVal.substring(4,attrVal.indexOf(')'));
    }
  }
  return null;
};

// Function: findDefs
// Parameters:
// svgElement - The <svg> element.
//
// Returns:
// The document's <defs> element, create it first if necessary
svgedit.utilities.findDefs = function(svgElement) {
  var svgElement = editorContext_.getSVGContent().documentElement;
  var defs = svgElement.getElementsByTagNameNS(SVGNS, "defs");
  if (defs.length > 0) {
    defs = defs[0];
  }
  else {
    // first child is a comment, so call nextSibling
    defs = svgElement.insertBefore( svgElement.ownerDocument.createElementNS(SVGNS, "defs" ), svgElement.firstChild.nextSibling);
  }
  return defs;
};

// Function: svgedit.utilities.getBBox
// Get the given/selected element's bounding box object, convert it to be more
// usable when necessary
//
// Parameters:
// elem - Optional DOM element to get the BBox for
svgedit.utilities.getBBox = function(elem) {
  var selected = elem || editorContext_.getSelectedElements()[0];
  if (elem.nodeType != 1) return null;
  var ret = null;
  var elname = selected.nodeName;
  
  switch ( elname ) {
  case 'text':
    if(selected.textContent === '') {
      selected.textContent = 'a'; // Some character needed for the selector to use.
      ret = selected.getBBox();
      selected.textContent = '';
    } else {
      try { ret = selected.getBBox();} catch(e){}
    }
    break;
  default:
     if(~visElems_arr.indexOf(elname)) {
      try { ret = selected.getBBox();} 
      catch(e) { 
        // Check if element is child of a foreignObject
        var fo = $(selected).closest("foreignObject");
        if(fo.length) {
          try {
            ret = fo[0].getBBox();
          } catch(e) {
            ret = null;
          }
        } else {
          ret = null;
        }
      }
    }
  }
  if(ret) {
    ret = svgedit.utilities.bboxToObj(ret);
  }
  // get the bounding box from the DOM (which is in that element's coordinate system)
  return ret;
};

// Function: svgedit.utilities.getRotationAngle
// Get the rotation angle of the given/selected DOM element
//
// Parameters:
// elem - Optional DOM element to get the angle for
// to_rad - Boolean that when true returns the value in radians rather than degrees
//
// Returns:
// Float with the angle in degrees or radians
svgedit.utilities.getRotationAngle = function(elem, to_rad) {
  var selected = elem || editorContext_.getSelectedElements()[0];
  // find the rotation transform (if any) and set it
  var tlist = svgedit.transformlist.getTransformList(selected);
  if(!tlist) return 0; // <svg> elements have no tlist
  var N = tlist.numberOfItems;
  for (var i = 0; i < N; ++i) {
    var xform = tlist.getItem(i);
    if (xform.type == 4) {
      return to_rad ? xform.angle * Math.PI / 180.0 : xform.angle;
    }
  }
  return 0.0;
};

// Function: getElem
// Get a DOM element by ID within the SVG root element.
//
// Parameters:
// id - String with the element's new ID
if (svgedit.browser.supportsSelectors()) {
  svgedit.utilities.getElem = function(id) {
    // querySelector lookup
    return svgroot_.querySelector('#'+id);
  };
} else if (svgedit.browser.supportsXpath()) {
  svgedit.utilities.getElem = function(id) {
    // xpath lookup
    return domdoc_.evaluate(
      'svg:svg[@id="svgroot"]//svg:*[@id="'+id+'"]',
      domcontainer_, 
      function() { return "http://www.w3.org/2000/svg"; },
      9,
      null).singleNodeValue;
  };
} else {
  svgedit.utilities.getElem = function(id) {
    // jQuery lookup: twice as slow as xpath in FF
    return $(svgroot_).find('[id=' + id + ']')[0];
  };
}

// Function: assignAttributes
// Assigns multiple attributes to an element.
//
// Parameters: 
// node - DOM element to apply new attribute values to
// attrs - Object with attribute keys/values
// unitCheck - Boolean to indicate the need to use svgedit.units.setUnitAttr
svgedit.utilities.assignAttributes = function(node, attrs, unitCheck) {
   for (var i in attrs) {
    var ns = (i.substr(0,4) === "xml:" ? XMLNS : 
      i.substr(0,6) === "xlink:" ? XLINKNS : null);
      
    if(ns) {
      node.setAttributeNS(ns, i, attrs[i]);
    } else if(!unitCheck) {
      node.setAttribute(i, attrs[i]);
    } else {
      svgedit.units.setUnitAttr(node, i, attrs[i]);
    }
    
  }
};

// Function: cleanupElement
// Remove unneeded (default) attributes, makes resulting SVG smaller
//
// Parameters:
// element - DOM element to clean up
svgedit.utilities.cleanupElement = function(element) {
  var defaults = {
    'fill-opacity':1,
    'stop-opacity':1,
    'opacity':1,
    'stroke':'none',
    'stroke-dasharray':'none',
    'stroke-opacity':1,
    'stroke-width':1,
    'rx':0,
    'ry':0
  }
  
  for(var attr in defaults) {
    var val = defaults[attr];
    if(element.getAttribute(attr) == val) {
      element.removeAttribute(attr);
    }
  }
  
};
})();

// svg icons
(function($) {
  var svg_icons = {}, fixIDs;
  $.svgIcons = function(file, opts) {
    var svgns = "http://www.w3.org/2000/svg",
      xlinkns = "http://www.w3.org/1999/xlink",
      icon_w = opts.w?opts.w : 24,
      icon_h = opts.h?opts.h : 24,
      elems, svgdoc, testImg,
      icons_made = false, data_loaded = false, load_attempts = 0,
      ua = navigator.userAgent, isOpera = !!window.opera, isSafari = (ua.indexOf('Safari/') > -1 && ua.indexOf('Chrome/')==-1),
      data_pre = 'data:image/svg+xml;charset=utf-8;base64,';
      
      if(opts.svgz) {
        var data_el = $('<object data="' + file + '" type=image/svg+xml>').appendTo('body').hide();
        try {
          svgdoc = data_el[0].contentDocument;
          data_el.load(getIcons);
          getIcons(0, true); // Opera will not run "load" event if file is already cached
        } catch(err1) {
          useFallback();
        }
      } else {
        var parser = new DOMParser();
        $.ajax({
          url: file,
          dataType: 'string',
          success: function(data) {
            if(!data) {
              $(useFallback);
              return;
            }
            svgdoc = parser.parseFromString(data, "text/xml");
            $(function() {
              getIcons('ajax');
            });
          },
          error: function(err) {
            // TODO: Fix Opera widget icon bug
            if(window.opera) {
              $(function() {
                useFallback();
              });
            } else {
              if(err.responseText) {
                svgdoc = parser.parseFromString(err.responseText, "text/xml");
                if(!svgdoc.childNodes.length) {
                  $(useFallback);                 
                }
                $(function() {
                  getIcons('ajax');
                });             
              } else {
                $(useFallback);
              }
            }
          }
        });
      }
      
    function getIcons(evt, no_wait) {
      if(evt !== 'ajax') {
        if(data_loaded) return;
        svgdoc = data_el[0].contentDocument; // Needed again for Webkit
        var isReady = (svgdoc && svgdoc.getElementById('svg_eof'));
        if(!isReady && !(no_wait && isReady)) {
          load_attempts++;
          if(load_attempts < 50) {
            setTimeout(getIcons, 20);
          } else {
            useFallback();
            data_loaded = true;
          }
          return;
        }
        data_loaded = true;
      }
      
      elems = $(svgdoc.firstChild).children(); //.getElementsByTagName('foreignContent');
      
      if(!opts.no_img) {
        var testSrc = data_pre + 'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNzUiIGhlaWdodD0iMjc1Ij48L3N2Zz4%3D';
        
        testImg = $(new Image()).attr({
          src: testSrc,
          width: 0,
          height: 0
        }).appendTo('body')
        .load(function () {
          // Safari 4 crashes, Opera and Chrome don't
          makeIcons(true);
        }).error(function () {
          makeIcons();
        });
      } else {
        setTimeout(function() {
          if(!icons_made) makeIcons();
        },500);
      }
    }
    
    var setIcon = function(target, icon, id, setID) {
      if(isOpera) icon.css('visibility','hidden');
      if(opts.replace) {
        if(setID) icon.attr('id',id);
        var cl = target.attr('class');
        if(cl) icon.attr('class','svg_icon '+cl);
        target.replaceWith(icon);
      } else {
        
        target.append(icon);
      }
      if(isOpera) {
        setTimeout(function() {
          icon.removeAttr('style');
        },1);
      }
    }
    
    var addIcon = function(icon, id) {
      if(opts.id_match === undefined || opts.id_match !== false) {
        console.log(holder,icon,id,true);
        setIcon(holder, icon, id, true);
      }
      svg_icons[id] = icon;
    }
    
    function makeIcons(toImage, fallback) {
      if(icons_made) return;
      if(opts.no_img) toImage = false;
      var holder;
      
      if(toImage) {
        var temp_holder = $(document.createElement('div'));
        temp_holder.hide().appendTo('body');
      } 
      if(fallback) {
        var path = opts.fallback_path?opts.fallback_path:'';
        $.each(fallback, function(id, imgsrc) {
          holder = $('#' + id);
          var icon = $(new Image())
            .attr({
              'class':'svg_icon',
              src: path + imgsrc,
              'width': icon_w,
              'height': icon_h,
              'alt': 'icon'
            });
          
          addIcon(icon, id);
        });
      } else {
        var len = elems.length;
        for(var i = 0; i < len; i++) {
          var elem = elems[i];
          var id = elem.id;
          if(id === 'svg_eof') break;
          holder = $('#' + id);
          var svg = elem.getElementsByTagNameNS(svgns, 'svg')[0];
          var svgroot = document.createElementNS(svgns, "svg");
          svgroot.setAttributeNS(svgns, 'viewBox', [0,0,icon_w,icon_h].join(' '));
          // Make flexible by converting width/height to viewBox
          var w = svg.getAttribute('width');
          var h = svg.getAttribute('height');
          svg.removeAttribute('width');
          svg.removeAttribute('height');
          
          var vb = svg.getAttribute('viewBox');
          if(!vb) {
            svg.setAttribute('viewBox', [0,0,w,h].join(' '));
          }
          
          // Not using jQuery to be a bit faster
          svgroot.setAttribute('xmlns', svgns);
          svgroot.setAttribute('width', icon_w);
          svgroot.setAttribute('height', icon_h);
          svgroot.setAttribute("xmlns:xlink", xlinkns);
          svgroot.setAttribute("class", 'svg_icon');

          // Without cloning, Firefox will make another GET request.
          // With cloning, causes issue in Opera/Win/Non-EN
          if(!isOpera) svg = svg.cloneNode(true);
          
          svgroot.appendChild(svg);
      
          if(toImage) {
            // Without cloning, Safari will crash
            // With cloning, causes issue in Opera/Win/Non-EN
            var svgcontent = isOpera?svgroot:svgroot.cloneNode(true);
            temp_holder.empty().append(svgroot);
            var str = data_pre + encode64(temp_holder.html());
            var icon = $(new Image())
              .attr({'class':'svg_icon', src:str});
          } else {
            var icon = fixIDs($(svgroot), i);
          }
          addIcon(icon, id);
        }

      }
      
      if(opts.placement) {
        $.each(opts.placement, function(sel, id) {
          if(!svg_icons[id]) return;
          $(sel).each(function(i) {
            var copy = svg_icons[id].clone();
            if(i > 0 && !toImage) copy = fixIDs(copy, i, true);
            setIcon($(this), copy, id);
          })
        });
      }
      if(!fallback) {
        if(toImage) temp_holder.remove();
        if(data_el) data_el.remove();
        if(testImg) testImg.remove();
      }
      if(opts.resize) $.resizeSvgIcons(opts.resize);
      icons_made = true;

      if(opts.callback) opts.callback(svg_icons);
    }
    
    fixIDs = function(svg_el, svg_num, force) {
      var defs = svg_el.find('defs');
      if(!defs.length) return svg_el;
      
      if(isOpera) {
        var id_elems = defs.find('*').filter(function() {
          return !!this.id;
        });
      } else {
        var id_elems = defs.find('[id]');
      }
      
      var all_elems = svg_el[0].getElementsByTagName('*'), len = all_elems.length;
      
      id_elems.each(function(i) {
        var id = this.id;
        var no_dupes = ($(svgdoc).find('#' + id).length <= 1);
        if(isOpera) no_dupes = false; // Opera didn't clone svg_el, so not reliable
        // if(!force && no_dupes) return;
        var new_id = 'x' + id + svg_num + i;
        this.id = new_id;
        
        var old_val = 'url(#' + id + ')';
        var new_val = 'url(#' + new_id + ')';

        for(var i = 0; i < len; i++) {
          var elem = all_elems[i];
          if(elem.getAttribute('fill') === old_val) {
            elem.setAttribute('fill', new_val);
          }
          if(elem.getAttribute('stroke') === old_val) {
            elem.setAttribute('stroke', new_val);
          }
          if(elem.getAttribute('filter') === old_val) {
            elem.setAttribute('filter', new_val);
          }
        }
      });
      return svg_el;
    }
    
    function useFallback() {
      if(file.indexOf('.svgz') != -1) {
        var reg_file = file.replace('.svgz','.svg');
        if(window.console) {
          console.log('.svgz failed, trying with .svg');
        }
        $.svgIcons(reg_file, opts);
      } else if(opts.fallback) {
        makeIcons(false, opts.fallback);
      }
    }
        
    function encode64(input) {
      // base64 strings are 4/3 larger than the original string
      if(window.btoa) return window.btoa(input);
      var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var output = new Array( Math.floor( (input.length + 2) / 3 ) * 4 );
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0, p = 0;
    
      do {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);
    
        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;
    
        if (isNaN(chr2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
          enc4 = 64;
        }
    
        output[p++] = _keyStr.charAt(enc1);
        output[p++] = _keyStr.charAt(enc2);
        output[p++] = _keyStr.charAt(enc3);
        output[p++] = _keyStr.charAt(enc4);
      } while (i < input.length);
    
      return output.join('');
    }
  }

  
  
  $.getSvgIcon = function(id, uniqueClone) { 
    var icon = svg_icons[id];
    if(uniqueClone && icon) {
      icon = fixIDs(icon, 0, true).clone(true);
    }
    return icon; 
  }
  
  $.resizeSvgIcons = function(obj) {
    // FF2 and older don't detect .svg_icon, so we change it detect svg elems instead
    var change_sel = !$('.svg_icon:first').length;
    $.each(obj, function(sel, size) {
      var arr = $.isArray(size);
      var w = arr?size[0]:size,
        h = arr?size[1]:size;
      if(change_sel) {
        sel = sel.replace(/\.svg_icon/g,'svg');
      }
      $(sel).each(function() {
        this.setAttribute('width', w);
        this.setAttribute('height', h);
        if(window.opera && window.widget) {
          this.parentNode.style.width = w + 'px';
          this.parentNode.style.height = h + 'px';
        }
      });
    });
  }
  
})(jQuery);